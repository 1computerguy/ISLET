#!/usr/bin/env bash
# Global Variables
CONFIG=LOCATION
AVAILABLE_USER=1

err(){
        MESSAGE="$1"
        logger -s -p local0.notice -t "islet" "$0: $MESSAGE"
        exit 1
}

# Retrieve globals
if [ -f $CONFIG ]; then
        source $CONFIG
        source $LIBISLET
	readonly CONFIG
	readonly LIBISLET
else
        err "Error: ${CONFIG:-config} or ${LIBISLET:-libislet} not found!"
        exit 1
fi

# Override with per image configuration
readonly CONFIGURATION="$1"
if [ -f "$CONFIG_DIR/$CONFIGURATION" ]
then
	source "$CONFIG_DIR/$CONFIGURATION"
else
	quit "Timeout occurred, config not selected!"
fi

readonly TIME=$(date +"%s")
readonly EXPIRATION=$(date --date=@$((TIME+86400*DAYS)) +"%c")
readonly DB
readonly USER
readonly PORT
readonly BIND
readonly INTERFACE

if [ ! -r $DB ]; then
        touch $DB
	chown ${USER}:${USER} $DB
	chmod 660 $DB
fi

identify(){
	local CHOICE
	ask "Are you a new or existing user? "
        option "new" "existing"
        read -r CHOICE
        echo

        if [[ "$CHOICE" = "new" ]] || [[ "$CHOICE" = "existing" ]]; then
                [[ "$CHOICE" = "new" ]] && new_user
                [[ "$CHOICE" = "existing" ]] && existing_user
        else
                try_again
        fi
}

new_user(){
        notice "A temporary account will be created so that you can resume your session."
        echo

        until test $AVAILABLE_USER -ne 1
        do
		ask "Choose a username: "
                option "a-zA-Z0-9"
                read -r USERNAME

                USERNAME=$(sanitize $USERNAME)
                echo "Your username is ${MF}$USERNAME${N}"
                verify_new_user
        done

	ask "Choose a password: "
        read -r -s PASSWORD
        echo
        ask "Verify your password: "
        read -r -s PASSWORD_VERIFY
        echo

        verify_new_password
}

existing_user(){
	local USERNAME
	local PASSWORD
	local USER_SUPPLIED_PASSWORD
	local HASH
	local COUNT=0
        notice "Your previous account is only valid for the length of the event, after that you must create a new account"
        echo
        while test $COUNT -lt $FAILURE_COUNT
        do
		ask "Username: "
                read -r USERNAME
                USERNAME=$(sanitize $USERNAME)
		ask "Password: "
                read -r -s PASSWORD
                echo
                USER_SUPPLIED_PASSWORD=$(echo "$PASSWORD" | sha1sum | sed 's/ .*//')
                HASH=$(awk -F : -v user=$USERNAME '$1 == user { print $2 }' $DB)
                if [ "$USER_SUPPLIED_PASSWORD" = "$HASH" ]
                then
                        echo "${MF}Success${N}"

			# This is how we handle using the same account for multiple images
			if ! awk -F : -v user="$USERNAME" -v basename="$BASENAME" '$1 == user \
			{
				for (i=4;i<=NF;i++)
					if ($i == basename ) {
						exit 0
					}
					exit 1
			}' $DB
			then
				start_container
			fi

			# User is re-attaching to previous image
                        log "${USERNAME}: Returning user from $CLIENT"
                        message "Welcome back!"
			is_debug "opt: start/attach ${BASENAME}.${USERNAME}"

                        docker start "${BASENAME}.${USERNAME}" > /dev/null 2>&1 && exec docker attach "${BASENAME}.${USERNAME}"
                        if [ $? -ne 0 ]; then
                                alert "Launching container failed! Please report to admins"
                                quit "Launching container failed!"
                        fi
                else
                        notice "Login Failed, try again."
                fi
                let COUNT++
        done
        alert "Too many failed attempts!"
        quit "$COUNT failed password verification attempts"
}

verify_new_user(){
        if grep -w -q "$USERNAME" $DB 2>/dev/null
	then
                notice "User already exists! Try a different one."
                AVAILABLE_USER=1
        else
                AVAILABLE_USER=0
        fi
}

verify_new_password(){
	local COUNT=0
	local HASH
        while [ "$PASSWORD" != "$PASSWORD_VERIFY" ]
        do
                if [ $COUNT -lt $FAILURE_COUNT ]
                then
                        notice "Passwords do not match! Try again."
			ask "Choose a password: "
                        read -r -s PASSWORD
                        echo
                        ask "Verify your password: "
                        read -r -s PASSWORD_VERIFY
                        echo
                else
                        alert "Too many failed attempts!"
                        quit "$COUNT failed password verification attempts"
                fi
        let COUNT++
        done

        readonly HASH=$(echo "$PASSWORD" | sha1sum | sed 's/ .*//')

        (
        flock --timeout 10 100 || quit "Couldn't obtain lock on file, try again later"
        echo "${USERNAME}:${HASH}:${TIME}" >> $DB
        ) 100>~/islet.lock

        log "${USERNAME}: Account created from $CLIENT"
        echo "Your account will expire on ${MF}$EXPIRATION${N}"
        start_container
}

try_again(){
	local TRY
	ask "I didn't understand your response. Would you like to try again? "
        option "Y" "N"
        read -r TRY
        if [[ "$TRY" = [YyNn] ]] || [[ "$TRY" = "[yY][eE]sS]" ]] || [[ "$TRY" = "[nN][oO]" ]]; then
                [[ "$TRY" = [Yy] ]] || [[ "$TRY" = "[yY][eE][sS]" ]] && clear && identify
                [[ "$TRY" = [Nn] ]] || [[ "$TRY" = "[nN][oO]" ]] && quit "User chose to exit from try_again"
        else
                quit "User forced to exit from try_again because of invalid response to question"
        fi
}

port_forwarding_setup() {
        # Use PPID and CLIENT as a way to associate the user with a container
        if [ $PORT ]; then

                # Re-attachment is impractical if we're keeping track with PPID
                removal_setup REMOVE=yes

                readonly PUBLISH="--publish $BIND:$PPID:$PORT"

                if [[ "$BIND" == "127.0.0.1" ]]; then
                        sudo sysctl -w net.ipv4.conf.${INTERFACE}.route_localnet=1 2>/dev/null
                        did_it_work "sysctl command failed to execute, check ${USER}'s permissions"
                fi
                # Client will be able to connect to an exposed container port via $SERVER:$PPID
                sudo iptables -t nat -I PREROUTING -i $INTERFACE -p tcp --source $CLIENT --dport $PPID -j DNAT --to ${BIND}:${PPID} 2>/dev/null
                did_it_work "iptables command failed to execute, check ${USER}'s permissions"
        fi
        # Cron job to remove old rules if the PPID doesn't exist any longer
}

removal_setup(){
        if [[ "$REMOVE" == "yes" ]]
        then
                echo
                notice "This container is set to be terminated upon exit, work will not be saved."
                REMOVE="--rm"
        else
                # Don't remove, instead keep track of the user's container for re-attachment
                sed -i "/$USERNAME/s/$/:$BASENAME/" $DB
                REMOVE=""
        fi
}

start_container(){

	removal_setup
	port_forwarding_setup

	local NAME_OPT="--name="${BASENAME}.${USERNAME}" -t -h $HOSTNAME"
	local RES_OPT="-c $CPU -m $RAM"
	local NET_OPT="$PUBLISH --net $NETWORK --dns $DNS"
	local GLB_OPT="$GLOBAL_OPTIONS"
	local OTH_OPT="$LOCAL_OPTIONS"
	local MNT_OPT="$MOUNT"
	local IMG_OPT="$REMOVE -i $IMAGE"
	local ENV_OPT="sudo -i -u $VIRTUSER $GLOBAL_ENV $LOCAL_ENV"

	# If debugging is yes
	is_debug "shell: CLIENT=$CLIENT SRCPORT=$SRCPORT SERVER=$SERVER DSTPORT=$DSTPORT SSH_TTY=$SSH_TTY TERM=$TERM PPID=$PPID TMOUT=$TMOUT"
	is_debug "opt: run $NAME_OPT $RES_OPT $NET_OPT $GLB_OPT $OTH_OPT \n\t$MNT_OPT $IMG_OPT $ENV_OPT"

        message "Enjoy yourself!"

	eval exec docker run "$NAME_OPT $RES_OPT $NET_OPT $GLB_OPT $OTH_OPT $MNT_OPT $IMG_OPT $ENV_OPT" $INFOLEVEL
}

trap 'echo; quit "Trap received, exiting..."' 1 2 3 20
identify
exit
